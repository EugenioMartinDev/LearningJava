package modelo.negocio;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import modelo.entidad.Cliente;
import modelo.persistencia.DaoClientes;
import utils.Constantes;


/**
 * 
 * Service to access to DDBB clientes.cliente and validate DNI
 * @author aula2m
 *
 */
@Service
public class GestorClientes {

	@Autowired
	private DaoClientes daoClientes = new DaoClientes();

	/**
	 * @return the daoClientes
	 */
	public DaoClientes getDaoClientes() {
		return daoClientes;
	}

	/**
	 * @param daoClientes the daoClientes to set
	 */
	public void setDaoClientes(DaoClientes daoClientes) {
		this.daoClientes = daoClientes;
	}


	/**
	 * Ask to update a new cliente : id is autogenerated in DDBB
	 * @param cliente
	 * @return SUCCESSFULL_EXECUTION if the cliente is inserted
	 *         ERROR_DNI_IS_NULL if cliente has not DNI (not possible because it is requested by scanner)
	 *         ERROR_DNI_IS_DUPLICATED if there is a cliente in DDBB with the same DNI asked to insert
	 *         ERROR_IN_DDBB if there is DDBB reports that the insertion was unsuccessful
	 */
	public int alta(Cliente cliente) {
		
		//Requisitos funcionales : DNI no puede ser nulo y no puede estar duplicados
		if (cliente.getDni().isEmpty()) {
			return Constantes.ERROR_DNI_IS_NULL;
		}

		if (buscarPorDni(cliente.getDni()).size() > 0) {
			return Constantes.ERROR_DNI_IS_DUPLICATED;
		}
				
		if (daoClientes.alta(cliente)) return Constantes.SUCCESSFULL_EXECUTION;
		else return Constantes.ERROR_IN_DDBB;
		
	}
	
	/**
	 * Ask the searching of a cliente when DNI is known
	 * @param dni
	 * @return a list of cliente or an empty list
	 */
	private List<Cliente> buscarPorDni(String dni) {
		return daoClientes.buscarPorDni(dni);
	}

	/**
	 * Ask the searching of a cliente when ID is known
	 * @param id
	 * @return a unique cliente or null
	 */
	public Cliente buscarPorId(int id) {
		return daoClientes.buscarPorId(id);
	}
	
	/**
	 * Ask the searching of a cliente when NOMBRE is known
	 * @param nombre
	 * @return a list of cliente or an empty list
	 */
	public List<Cliente> buscarPorNombre(String nombre) {
		return daoClientes.buscarPorNombre(nombre);
		
	}
	

	/**
	 * Ask for all cliente in BBDD
	 * @return a list of cliente or an empty list
	 */
	public List<Cliente> lista() {
		return daoClientes.listar();
	}
	
	
	
	/**
	 * Ask to delete a cliente 
	 * @param id
	 * @return 0 if cliente has been removed from DDBB
	 *         1 if cliente has not been removed
	 */
	public boolean borrar(int id) {
		return daoClientes.borrar(id);

	}
	
	
	//Requisitos funcionales: DNI con 9 caracteres y que acabe en letra
	/**
	 * Check if DNI is valid
	 * @param dni
	 * @return SUCCESSFULL_EXECUTION if DNI is correct
	 * 			ERROR_DNI_LENGTH if DNI length if not nine (9) characters
	 * 			ERROR_DNI_WRONG_LETTER if DNI has a letter in the first eight (8) characters or DNI has not a valid letter
	 *          ("T","R","W","A","G","M","Y","F","P","D","X","B","N","J","Z","S","Q","V","H","L","C","K","E") in the nine (9) character
	 */
	public int comprobarDNI(String dni) {
			
		/*
		if (dni.length() != 9) {
			return Constantes.ERROR_DNI_LENGTH;
		}
		*/
		
		/*
		
		String letra = dni.substring(dni.length()-1).toUpperCase();
		
		List<String> listaCaracteresDni = new ArrayList<String> (
			Arrays.asList("T","R","W","A","G","M","Y","F","P","D","X","B","N","J","Z","S","Q","V","H","L","C","K","E") 
		);
		
		boolean found = false;
		for (String elemento : listaCaracteresDni) {
			if (elemento.contentEquals(letra)) {
				found = true;
			}
		}
		if (!found) return Constantes.ERROR_DNI_WRONG_LETTER;
		
		return Constantes.SUCCESSFULL_EXECUTION;
		
		*/
		
		/*
		 *  if(dni.length() != 9 || Character.isLetter(dni.charAt(8)) == false ) {
            return false;
        }
		 */
		
		
		
		boolean validar = validarNIF(dni);
		if (validar) { 
			return Constantes.SUCCESSFULL_EXECUTION;
		} else 
			return Constantes.ERROR_DNI_WRONG_LETTER;
			
		
	}

	/**
	 * Private function to validate DNI
	 * @param nif
	 * @return true if DNI is correct
	 *         false if DNI length if not nine (9) characters
	 * 			ERROR_DNI_WRONG_LETTER if DNI has a letter in the first eight (8) characters or DNI has not a valid letter
	 *          ("T","R","W","A","G","M","Y","F","P","D","X","B","N","J","Z","S","Q","V","H","L","C","K","E") in the nine (9) character 
	 */
	private boolean validarNIF(String nif) {

	    boolean correcto = false;
	    
	    Pattern pattern = Pattern.compile("(\\d+)*([(TRWAGMYFPDXBNJZSQVHLCKEtrwagmyfpdxbnjzsqvhlcke)]+)*");
	    Matcher matcher = pattern.matcher(nif);
	    
	    boolean formated = matcher.find();

	    
	    if (matcher.find())
	    {
		    if (matcher.group(1) == null || matcher.group(2) == null) { 
		    	System.out.println("Formato erróneo");
		    } else {
		    	if (matcher.group(1).length() != 8) {
		    		System.out.println("Debe tener 8 dígitos");
		    	} else {
		    		if (matcher.group(2).length() != 1) {
		    			System.out.println("Debe tener una única letra");
		    		} else {
				        String letra = matcher.group(2);
				        String letras = "TRWAGMYFPDXBNJZSQVHLCKE";
				        int index = Integer.parseInt(matcher.group(1));
				        index = index % 23;
				        String reference = letras.substring(index, index + 1);
				        if (reference.equalsIgnoreCase(letra)) {
				            correcto = true;
				        } else {
				        	System.out.println(" No existe correspondencia de los dígitos con la letra. Probar con la letra : " + reference);
				            correcto = false;
				        }
		    		}
		    	}
		    }
	    } else {
	    	System.out.println("Formato erróneo");
	    	correcto = false;
	    }
	    
	    return correcto;

	}

	
}
